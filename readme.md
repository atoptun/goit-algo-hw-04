## Результати завдання 3

Я вирішив розширити список алгоритмів для порівняння.

Проведений замір часу виконання різних алгоритмів. Результати представлені в таблиці (час в секундах).

| Algorithm            | Time small data (1K) | Time medium data (10K) | Time large data (100K) | Time huge data (1M) 
| -------------------- | -------------------- | -------------------- | -------------------- | --------------------
| Bubble               | 0.09953              | 11.22137             | None                 | None                
| Insertion            | 0.04240              | 4.55947              | 607.94005            | None                
| Merge                | 0.00376              | 0.04990              | 0.67680              | 10.10547            
| Quick                | 0.00353              | 0.04556              | 0.63942              | 11.93734            
| Shell                | 0.00374              | 0.06373              | 1.34155              | 28.81572            
| Tim sorted           | 0.00035              | 0.00478              | 0.07025              | 1.01691             
| Tim sort             | 0.00008              | 0.00098              | 0.01757              | 0.27439  


По наведеним замірам ми бачимо підтвердження теоретичної оцінки часової складності алгоритмів.

*Алгоритми* $O(n^2)$ - Bubble sort та Insertion sort - підходять як навчальний алгоритм, але не використовується в робочих проектах.

*Алгоритми* $O(n \space log \space n)$ - Merge sort, Quick sort та Shell sort - також підходять тільки для навчання.

*Оптимізовані алгоритми* $O(n \space log \space n)$ - Tim sort - показав найкращі результати - підтверджує, чому він використовується у Python як стандартний алгоритм сортування. Окрім того, він реалізований на рівні CPython з максимальною оптимізацією.

Здивувала різниця між **sorted()** і **list.sort()** - в якості пояснення наводиться те, що **sorted()** додатково витрачає ресурси на виділення пам'яті і копіювання даних, в той час як **list.sort()** прцює з вже виділеною пам'ятью. Тобто, якщо не потрібно зберігати начальний список, то краще використовувати **list.sort()**.
